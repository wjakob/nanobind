from numpy.typing import ArrayLike
from typing import Annotated, overload

class Cls:
    def __init__(self) -> None: ...

    def f1(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f2(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f1_ri(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f2_ri(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f3_ri(self, arg: object, /) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

def accept_ro(arg: Annotated[ArrayLike, dict(dtype='float32', writable=False, shape=(2))], /) -> float: ...

def accept_rw(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2))], /) -> float: ...

def cast(arg: bool, /) -> ArrayLike: ...

def check(arg: object, /) -> bool: ...

def check_bool(arg: ArrayLike, /) -> bool: ...

@overload
def check_device(arg: Annotated[ArrayLike, dict(device='cpu')], /) -> str: ...

@overload
def check_device(arg: Annotated[ArrayLike, dict(device='cuda')], /) -> str: ...

def check_float(arg: ArrayLike, /) -> bool: ...

@overload
def check_order(arg: Annotated[ArrayLike, dict(order='C')], /) -> str: ...

@overload
def check_order(arg: Annotated[ArrayLike, dict(order='F')], /) -> str: ...

@overload
def check_order(arg: ArrayLike, /) -> str: ...

def check_shape_ptr(arg: ArrayLike, /) -> bool: ...

def check_stride_ptr(arg: ArrayLike, /) -> bool: ...

def destruct_count() -> int: ...

def fill_view_1(x: ArrayLike) -> None: ...

def fill_view_2(x: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None), device='cpu')]) -> None: ...

def fill_view_3(x: Annotated[ArrayLike, dict(dtype='float32', shape=(3, 4), order='C', device='cpu')]) -> None: ...

def fill_view_4(x: Annotated[ArrayLike, dict(dtype='float32', shape=(3, 4), order='F', device='cpu')]) -> None: ...

def fill_view_5(x: Annotated[ArrayLike, dict(dtype='complex64', shape=(2, 2), order='C', device='cpu')]) -> None: ...

def get_itemsize(array: ArrayLike) -> int: ...

def get_nbytes(array: ArrayLike) -> int: ...

def get_shape(array: Annotated[ArrayLike, dict(writable=False)]) -> list: ...

def get_size(array: ArrayLike) -> int: ...

def implicit(array: Annotated[ArrayLike, dict(dtype='float32', order='C', shape=(2, 2))]) -> int: ...

@overload
def initialize(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(10), device='cpu')], /) -> None: ...

@overload
def initialize(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(10, None), device='cpu')], /) -> None: ...

def inspect_ndarray(arg: ArrayLike, /) -> None: ...

def make_contig(arg: Annotated[ArrayLike, dict(order='C')], /) -> Annotated[ArrayLike, dict(order='C')]: ...

def noimplicit(array: Annotated[ArrayLike, dict(dtype='float32', order='C', shape=(2, 2))]) -> int: ...

def noop_2d_f_contig(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None), order='F')], /) -> None: ...

def noop_3d_c_contig(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None, None), order='C')], /) -> None: ...

def pass_bool(array: Annotated[ArrayLike, dict(dtype='bool')]) -> None: ...

def pass_complex64(array: Annotated[ArrayLike, dict(dtype='complex64')]) -> None: ...

def pass_complex64_const(array: Annotated[ArrayLike, dict(dtype='complex64', writable=False)]) -> None: ...

def pass_float32(array: Annotated[ArrayLike, dict(dtype='float32')]) -> None: ...

def pass_float32_const(array: Annotated[ArrayLike, dict(dtype='float32', writable=False)]) -> None: ...

def pass_float32_shaped(array: Annotated[ArrayLike, dict(dtype='float32', shape=(3, None, 4))]) -> None: ...

def pass_float32_shaped_ordered(array: Annotated[ArrayLike, dict(dtype='float32', order='C', shape=(None, None, 4))]) -> None: ...

def pass_uint32(array: Annotated[ArrayLike, dict(dtype='uint32')]) -> None: ...

def passthrough(arg: ArrayLike, /) -> ArrayLike: ...

def passthrough_copy(arg: ArrayLike, /) -> ArrayLike: ...

def process(arg: Annotated[ArrayLike, dict(dtype='uint8', shape=(None, None, 3), order='C', device='cpu')], /) -> None: ...

def ret_array_scalar() -> Annotated[ArrayLike, dict(dtype='float32')]: ...

def ret_numpy() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

def ret_numpy_const() -> Annotated[ArrayLike, dict(dtype='float32', writable=False, shape=(2, 4))]: ...

def ret_numpy_const_ref() -> Annotated[ArrayLike, dict(dtype='float32', writable=False, shape=(2, 4))]: ...

def ret_numpy_half() -> Annotated[ArrayLike, dict(dtype='float16', shape=(2, 4))]: ...

def ret_pytorch() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

def return_dlpack() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

@overload
def set_item(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg1: int, /) -> None: ...

@overload
def set_item(arg0: Annotated[ArrayLike, dict(dtype='complex128', shape=(None), order='C')], arg1: int, /) -> None: ...
