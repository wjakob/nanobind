from collections.abc import Callable, Mapping, Sequence, Set
import os
import pathlib
from typing import overload


def stats() -> dict: ...

def reset() -> None: ...

class Movable:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class Copyable:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class NonAssignable:
    def __init__(self) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class NonDefaultConstructible:
    def __init__(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class StructWithReadonlyMap:
    def __init__(self) -> None: ...

    @property
    def map(self) -> dict[str, int]: ...

def return_movable() -> Movable: ...

def return_movable_ptr() -> Movable: ...

def movable_in_value(arg: Movable, /) -> None: ...

def movable_in_lvalue_ref(arg: Movable, /) -> None: ...

def movable_in_rvalue_ref(arg: Movable, /) -> None: ...

def movable_in_ptr(arg: Movable, /) -> None: ...

def return_copyable() -> Copyable: ...

def return_copyable_ptr() -> Copyable: ...

def copyable_in_value(arg: Copyable, /) -> None: ...

def copyable_in_lvalue_ref(arg: Copyable, /) -> None: ...

def copyable_in_rvalue_ref(arg: Copyable, /) -> None: ...

def copyable_in_ptr(arg: Copyable, /) -> None: ...

def tuple_return_movable() -> tuple[Movable]: ...

def tuple_return_movable_ptr() -> tuple[Movable]: ...

def tuple_movable_in_value(arg: tuple[Movable], /) -> None: ...

def tuple_movable_in_lvalue_ref(arg: tuple[Movable], /) -> None: ...

def tuple_movable_in_lvalue_ref_2(arg: tuple[Movable], /) -> None: ...

def tuple_movable_in_rvalue_ref(arg: tuple[Movable], /) -> None: ...

def tuple_movable_in_rvalue_ref_2(arg: tuple[Movable], /) -> None: ...

def tuple_movable_in_ptr(arg: tuple[Movable], /) -> None: ...

def empty_tuple(arg: tuple[()], /) -> tuple[()]: ...

def swap_tuple(arg: tuple[int, float], /) -> tuple[float, int]: ...

def swap_pair(arg: tuple[int, float], /) -> tuple[float, int]: ...

def vec_return_movable() -> list[Movable]: ...

def vec_return_copyable() -> list[Copyable]: ...

def vec_movable_in_value(arg: Sequence[Movable], /) -> None: ...

def vec_copyable_in_value(arg: Sequence[Copyable], /) -> None: ...

def vec_movable_in_lvalue_ref(arg: Sequence[Movable], /) -> None: ...

def vec_movable_in_rvalue_ref(arg: Sequence[Movable], /) -> None: ...

def vec_movable_in_ptr_2(arg: Sequence[Movable], /) -> None: ...

class float_vec:
    def __init__(self) -> None: ...

    def push_back(self, arg: float, /) -> None: ...

    def size(self) -> int: ...

def return_empty_function() -> Callable[[int], int]: ...

def return_function() -> Callable[[int], int]: ...

def call_function(arg0: Callable[[int], int], arg1: int, /) -> int: ...

def return_void_function(arg: Callable[[], None], /) -> Callable[[], None]: ...

def identity_list(arg: Sequence[int], /) -> list[int]: ...

class FuncWrapper:
    def __init__(self) -> None: ...

    @property
    def f(self) -> Callable[[], None]: ...

    @f.setter
    def f(self, arg: Callable[[], None], /) -> None: ...

    alive: int = ...
    """static read-only property"""

def identity_string(arg: str, /) -> str: ...

def identity_string_view(arg: str, /) -> str: ...

def optional_copyable(x: Copyable | None) -> None: ...

def optional_copyable_ptr(x: Copyable | None) -> None: ...

def optional_none(x: Copyable | None) -> None: ...

def optional_ret_opt_movable() -> Movable | None: ...

def optional_ret_opt_movable_ptr() -> Movable | None: ...

def optional_ret_opt_none() -> Movable | None: ...

def optional_unbound_type(x: int | None = None) -> int | None: ...

def optional_unbound_type_with_nullopt_as_default(x: int | None = None) -> int | None: ...

def optional_non_assignable(arg: NonAssignable, /) -> NonAssignable | None: ...

def variant_copyable(arg: Copyable | int, /) -> None: ...

def variant_copyable_none(x: int | Copyable | None) -> None: ...

def variant_copyable_ptr(arg: Copyable | int, /) -> None: ...

def variant_copyable_ptr_none(x: Copyable | int | None) -> None: ...

def variant_ret_var_copyable() -> Copyable | int: ...

def variant_ret_var_none() -> None | Copyable | int: ...

def variant_unbound_type(x: list | tuple | int | None = None) -> None | list | tuple | int: ...

def variant_nondefault(arg: NonDefaultConstructible | int, /) -> int: ...

def map_return_movable_value() -> dict[str, Movable]: ...

def map_return_copyable_value() -> dict[str, Copyable]: ...

def map_movable_in_value(x: Mapping[str, Movable]) -> None: ...

def map_copyable_in_value(x: Mapping[str, Copyable]) -> None: ...

def map_movable_in_lvalue_ref(x: Mapping[str, Movable]) -> None: ...

def map_movable_in_rvalue_ref(x: Mapping[str, Movable]) -> None: ...

def map_movable_in_ptr(x: Mapping[str, Movable]) -> None: ...

def map_return_readonly_value() -> StructWithReadonlyMap: ...

def array_out() -> list[int]: ...

def array_in(arg: Sequence[int], /) -> int: ...

def set_return_value() -> set[str]: ...

def unordered_set_return_value() -> set[str]: ...

def set_in_value(x: Set[str]) -> None: ...

def unordered_set_in_value(x: Set[str]) -> None: ...

def set_in_lvalue_ref(x: Set[str]) -> None: ...

def set_in_rvalue_ref(x: Set[str]) -> None: ...

def replace_extension(arg0: str | os.PathLike, arg1: str, /) -> pathlib.Path: ...

def parent_path(arg: str | os.PathLike, /) -> pathlib.Path: ...

class ClassWithMovableField:
    def __init__(self) -> None: ...

    @property
    def movable(self) -> list[Movable]: ...

    @movable.setter
    def movable(self, arg: Sequence[Movable], /) -> None: ...

def flip_vector_bool(arg: Sequence[bool], /) -> list[bool]: ...

def complex_value_float(arg: complex, /) -> complex: ...

def complex_value_float_nc(arg: complex) -> complex: ...

def complex_value_double(arg: complex, /) -> complex: ...

def complex_value_double_nc(arg: complex) -> complex: ...

def complex_array_float(arg: Sequence[complex], /) -> list[complex]: ...

def complex_array_double(arg: Sequence[complex], /) -> list[complex]: ...

@overload
def vector_str(arg: Sequence[str], /) -> list[str]: ...

@overload
def vector_str(arg: str, /) -> str: ...

def vector_optional_str(arg: Sequence[str | None], /) -> list[str | None]: ...

def pass_wstr(arg: str, /) -> str: ...

def optional_cstr(arg: str | None) -> str: ...

class BasicID1:
    def __init__(self, arg: int, /) -> None: ...

    def __int__(self) -> int: ...

class BasicID2:
    def __init__(self, arg: int, /) -> None: ...

class IDHavingEvent:
    def __init__(self) -> None: ...

    @property
    def id(self) -> None | BasicID2 | BasicID1: ...

    @id.setter
    def id(self, arg: BasicID2 | BasicID1, /) -> None: ...
