from typing import Annotated, overload

import jaxlib.xla_extension
from numpy.typing import ArrayLike
import tensorflow.python.framework.ops


class Cls:
    def __init__(self) -> None: ...

    def f1(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f2(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f1_ri(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f2_ri(self) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

    def f3_ri(self, arg: object, /) -> Annotated[ArrayLike, dict(dtype='float32')]: ...

class Matrix4f:
    def __init__(self) -> None: ...

    def data(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]: ...

    def data_ref(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]: ...

    def data_copy(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]: ...

def accept_ro(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), writable=False)], /) -> float: ...

def accept_rw(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2))], /) -> float: ...

def cast(arg: bool, /) -> ArrayLike: ...

def check(arg: object, /) -> bool: ...

def check_bool(arg: ArrayLike, /) -> bool: ...

@overload
def check_device(arg: Annotated[ArrayLike, dict(device='cpu')], /) -> str: ...

@overload
def check_device(arg: Annotated[ArrayLike, dict(device='cuda')], /) -> str: ...

def check_float(arg: ArrayLike, /) -> bool: ...

@overload
def check_order(arg: Annotated[ArrayLike, dict(order='C')], /) -> str: ...

@overload
def check_order(arg: Annotated[ArrayLike, dict(order='F')], /) -> str: ...

@overload
def check_order(arg: ArrayLike, /) -> str: ...

def check_ro_by_const_ref_const_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), writable=False)], /) -> bool: ...

def check_ro_by_const_ref_ro(arg: Annotated[ArrayLike, dict(writable=False)], /) -> bool: ...

def check_ro_by_rvalue_ref_const_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), writable=False)], /) -> bool: ...

def check_ro_by_rvalue_ref_ro(arg: Annotated[ArrayLike, dict(writable=False)], /) -> bool: ...

def check_ro_by_value_const_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None), writable=False)], /) -> bool: ...

def check_ro_by_value_ro(arg: Annotated[ArrayLike, dict(writable=False)], /) -> bool: ...

def check_rw_by_const_ref(arg: ArrayLike, /) -> bool: ...

def check_rw_by_const_ref_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None))], /) -> bool: ...

def check_rw_by_rvalue_ref(arg: ArrayLike, /) -> bool: ...

def check_rw_by_rvalue_ref_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None))], /) -> bool: ...

def check_rw_by_value(arg: ArrayLike, /) -> bool: ...

def check_rw_by_value_float64(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(None))], /) -> bool: ...

def check_shape_ptr(arg: ArrayLike, /) -> bool: ...

def check_stride_ptr(arg: ArrayLike, /) -> bool: ...

def destruct_count() -> int: ...

def fill_view_1(x: ArrayLike) -> None: ...

def fill_view_2(x: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None), device='cpu')]) -> None: ...

def fill_view_3(x: Annotated[ArrayLike, dict(dtype='float32', shape=(3, 4), order='C', device='cpu')]) -> None: ...

def fill_view_4(x: Annotated[ArrayLike, dict(dtype='float32', shape=(3, 4), order='F', device='cpu')]) -> None: ...

def fill_view_5(x: Annotated[ArrayLike, dict(dtype='complex64', shape=(2, 2), order='C', device='cpu')]) -> None: ...

def fill_view_6(x: Annotated[ArrayLike, dict(dtype='complex64', shape=(2, 2), order='C', device='cpu')]) -> None: ...

def get_is_valid(array: Annotated[ArrayLike, dict(writable=False)] | None) -> bool: ...

def get_itemsize(array: ArrayLike | None) -> int: ...

def get_nbytes(array: ArrayLike | None) -> int: ...

def get_shape(array: Annotated[ArrayLike, dict(writable=False)]) -> list: ...

def get_size(array: ArrayLike | None) -> int: ...

def get_stride(array: ArrayLike, i: int) -> int: ...

def implicit(array: Annotated[ArrayLike, dict(dtype='float32', shape=(2, 2), order='C')]) -> int: ...

@overload
def initialize(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(10), device='cpu')], /) -> None: ...

@overload
def initialize(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(10, None), device='cpu')], /) -> None: ...

def inspect_ndarray(arg: ArrayLike, /) -> None: ...

def make_contig(arg: Annotated[ArrayLike, dict(order='C')], /) -> Annotated[ArrayLike, dict(order='C')]: ...

def noimplicit(array: Annotated[ArrayLike, dict(dtype='float32', shape=(2, 2), order='C')]) -> int: ...

def noop_2d_f_contig(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None), order='F')], /) -> None: ...

def noop_3d_c_contig(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None, None), order='C')], /) -> None: ...

def pass_bool(array: Annotated[ArrayLike, dict(dtype='bool')]) -> None: ...

def pass_complex64(array: Annotated[ArrayLike, dict(dtype='complex64')]) -> None: ...

def pass_complex64_const(array: Annotated[ArrayLike, dict(dtype='complex64', writable=False)]) -> None: ...

def pass_float32(array: Annotated[ArrayLike, dict(dtype='float32')]) -> None: ...

def pass_float32_const(array: Annotated[ArrayLike, dict(dtype='float32', writable=False)]) -> None: ...

def pass_float32_shaped(array: Annotated[ArrayLike, dict(dtype='float32', shape=(3, None, 4))]) -> None: ...

def pass_float32_shaped_ordered(array: Annotated[ArrayLike, dict(dtype='float32', shape=(None, None, 4), order='C')]) -> None: ...

def pass_uint32(array: Annotated[ArrayLike, dict(dtype='uint32')]) -> None: ...

def passthrough(arg: ArrayLike, /) -> ArrayLike: ...

def passthrough_arg_none(arg: ArrayLike | None) -> ArrayLike: ...

def passthrough_copy(arg: ArrayLike, /) -> ArrayLike: ...

def process(arg: Annotated[ArrayLike, dict(dtype='uint8', shape=(None, None, 3), order='C', device='cpu')], /) -> None: ...

def ret_array_scalar() -> Annotated[ArrayLike, dict(dtype='float32')]: ...

def ret_from_stack_1() -> object: ...

def ret_from_stack_2() -> Annotated[ArrayLike, dict(dtype='float32', shape=(3))]: ...

def ret_infer_c() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4), order='C')]: ...

def ret_infer_f() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4), order='F')]: ...

def ret_jax() -> jaxlib.xla_extension.DeviceArray[dtype=float32, shape=(2, 4)]: ...

def ret_numpy() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

def ret_numpy_const() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4), writable=False)]: ...

def ret_numpy_const_ref() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4), order='C', writable=False)]: ...

def ret_numpy_const_ref_f() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4), order='F', writable=False)]: ...

def ret_pytorch() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

def ret_tensorflow() -> tensorflow.python.framework.ops.EagerTensor[dtype=float32, shape=(2, 4)]: ...

def return_dlpack() -> Annotated[ArrayLike, dict(dtype='float32', shape=(2, 4))]: ...

@overload
def set_item(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg1: int, /) -> None: ...

@overload
def set_item(arg0: Annotated[ArrayLike, dict(dtype='complex128', shape=(None), order='C')], arg1: int, /) -> None: ...

def test_implicit_conversion(arg: Annotated[ArrayLike, dict(order='C', device='cpu', writable=False)]) -> Annotated[ArrayLike, dict(order='C', device='cpu', writable=False)]: ...
